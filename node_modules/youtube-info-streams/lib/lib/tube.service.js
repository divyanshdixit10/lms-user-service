"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YTubeService = void 0;
var got_1 = require("got");
var jsonClosingChars = /^[)\]}'\s]+/;
// tslint:disable-next-line:one-variable-per-declaration
var IOS_CLIENT_VERSION = '19.28.1', IOS_DEVICE_MODEL = 'iPhone16,2', IOS_USER_AGENT_VERSION = '17_5_1', IOS_OS_VERSION = '17.5.1.21F90';
// tslint:disable-next-line:one-variable-per-declaration
var ANDROID_CLIENT_VERSION = '19.30.36', ANDROID_OS_VERSION = '14', ANDROID_SDK_VERSION = '34';
/**
 * Escape sequences for cutAfterJS
 * @param {string} start the character string the escape sequence
 * @param {string} end the character string to stop the escape seequence
 * @param {undefined|Regex} startPrefix a regex to check against the preceding 10 characters
 */
var ESCAPING_SEQUENZES = [
    // Strings
    { start: '"', end: '"' },
    { start: "'", end: "'" },
    { start: '`', end: '`' },
    // RegeEx
    { start: '/', end: '/', startPrefix: /(^|[[{:;,/])\s?$/ },
];
var YTubeService = /** @class */ (function () {
    function YTubeService() {
        var _this = this;
        this.BASE_URL = 'https://www.youtube.com/watch?v=';
        /*
      * Extract string inbetween another.
      */
        this.tryParseBetween = function (body, left, right, prepend, append) {
            if (prepend === void 0) { prepend = ''; }
            if (append === void 0) { append = ''; }
            try {
                var data = _this.between(body, left, right);
                if (!data)
                    return null;
                return JSON.parse("".concat(prepend).concat(data).concat(append));
            }
            catch (e) {
                return null;
            }
        };
    }
    YTubeService.prototype.findJSON = function (source, varName, body, left, right, prependJSON, tubeService) {
        var jsonStr = tubeService.between(body, left, right);
        if (!jsonStr) {
            throw Error("Could not find ".concat(varName, " in ").concat(source));
        }
        return tubeService.parseJSON(source, varName, tubeService.cutAfterJS("".concat(prependJSON).concat(jsonStr)));
    };
    ;
    YTubeService.prototype.cutAfterJS = function (mixedJson) {
        // Define the general open and closing tag
        // tslint:disable-next-line:one-variable-per-declaration
        var open, close;
        if (mixedJson[0] === '[') {
            open = '[';
            close = ']';
        }
        else if (mixedJson[0] === '{') {
            open = '{';
            close = '}';
        }
        if (!open) {
            throw new Error("Can't cut unsupported JSON (need to begin with [ or { ) but got: ".concat(mixedJson[0]));
        }
        // States if the loop is currently inside an escaped js object
        var isEscapedObject = null;
        // States if the current character is treated as escaped or not
        var isEscaped = false;
        // Current open brackets to be closed
        var counter = 0;
        var i;
        // Go through all characters from the start
        for (i = 0; i < mixedJson.length; i++) {
            // End of current escaped object
            if (!isEscaped && isEscapedObject !== null && mixedJson[i] === isEscapedObject.end) {
                isEscapedObject = null;
                continue;
                // Might be the start of a new escaped object
            }
            else if (!isEscaped && isEscapedObject === null) {
                for (var _i = 0, ESCAPING_SEQUENZES_1 = ESCAPING_SEQUENZES; _i < ESCAPING_SEQUENZES_1.length; _i++) {
                    var escaped = ESCAPING_SEQUENZES_1[_i];
                    if (mixedJson[i] !== escaped.start)
                        continue;
                    // Test startPrefix against last 10 characters
                    if (!escaped.startPrefix || mixedJson.substring(i - 10, i).match(escaped.startPrefix)) {
                        isEscapedObject = escaped;
                        break;
                    }
                }
                // Continue if we found a new escaped object
                if (isEscapedObject !== null) {
                    continue;
                }
            }
            // Toggle the isEscaped boolean for every backslash
            // Reset for every regular character
            isEscaped = mixedJson[i] === '\\' && !isEscaped;
            if (isEscapedObject !== null)
                continue;
            if (mixedJson[i] === open) {
                counter++;
            }
            else if (mixedJson[i] === close) {
                counter--;
            }
            // All brackets have been closed, thus end of JSON is reached
            if (counter === 0) {
                // Return the cut JSON
                return mixedJson.substring(0, i + 1);
            }
        }
        // We ran through the whole string and ended up with an unclosed bracket
        throw Error("Can't cut unsupported JSON (no matching closing bracket found)");
    };
    ;
    YTubeService.prototype.findPlayerResponse = function (source, info, tubeService) {
        // tslint:disable-next-line:variable-name
        var player_response = info && ((info.args && info.args.player_response) ||
            info.player_response || info.playerResponse || info.embedded_player_response);
        return tubeService.parseJSON(source, 'player_response', player_response);
    };
    ;
    YTubeService.prototype.getHTML5player = function (body) {
        var html5playerRes = /<script\s+src="([^"]+)"(?:\s+type="text\/javascript")?\s+name="player_ias\/base"\s*>|"jsUrl":"([^"]+)"/
            .exec(body);
        return html5playerRes ? html5playerRes[1] || html5playerRes[2] : null;
    };
    ;
    YTubeService.prototype.parseJSON = function (source, varName, json) {
        if (!json || typeof json === 'object') {
            return json;
        }
        else {
            try {
                json = json.replace(jsonClosingChars, '');
                return JSON.parse(json);
            }
            catch (err) {
                throw Error("Error parsing ".concat(varName, " in ").concat(source, ": ").concat(err));
            }
        }
    };
    ;
    YTubeService.prototype.gotConfig = function (id, additional, info, tubeService) {
        return __awaiter(this, void 0, void 0, function () {
            var funcs, _a, iosPlayerResponse, androidPlayerResponse, results;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        funcs = [];
                        return [4 /*yield*/, Promise.all([
                                tubeService.fetchIosJsonPlayer(id, tubeService),
                                tubeService.fetchAndroidJsonPlayer(id, tubeService),
                            ])];
                    case 1:
                        _a = _b.sent(), iosPlayerResponse = _a[0], androidPlayerResponse = _a[1];
                        info.formats = this.parseFormats(androidPlayerResponse).concat(this.parseFormats(iosPlayerResponse));
                        if (info.formats.length) {
                            funcs.push(info.formats);
                        }
                        return [4 /*yield*/, Promise.all(funcs)];
                    case 2:
                        results = _b.sent();
                        info.formats = Object.values(Object.assign.apply(Object, __spreadArray([{}], results, false)));
                        return [2 /*return*/, info];
                }
            });
        });
    };
    YTubeService.prototype.generateClientPlaybackNonce = function (length) {
        var CPN_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
        return Array.from({ length: length }, function () { return CPN_CHARS[Math.floor(Math.random() * CPN_CHARS.length)]; }).join('');
    };
    ;
    YTubeService.prototype.fetchIosJsonPlayer = function (videoId, tubeService) {
        return __awaiter(this, void 0, void 0, function () {
            var payload, response, body, playErr;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        payload = {
                            videoId: videoId,
                            cpn: tubeService.generateClientPlaybackNonce(16),
                            contentCheckOk: true,
                            racyCheckOk: true,
                            context: {
                                client: {
                                    clientName: 'IOS',
                                    clientVersion: IOS_CLIENT_VERSION,
                                    deviceMake: 'Apple',
                                    deviceModel: IOS_DEVICE_MODEL,
                                    platform: 'MOBILE',
                                    osName: 'iOS',
                                    osVersion: IOS_OS_VERSION,
                                    hl: 'en',
                                    gl: 'US',
                                    utcOffsetMinutes: -240,
                                },
                                request: {
                                    internalExperimentFlags: [],
                                    useSsl: true,
                                },
                                user: {
                                    lockedSafetyMode: false,
                                },
                            },
                        };
                        return [4 /*yield*/, got_1.default.post("https://youtubei.googleapis.com/youtubei/v1/player?id=".concat(videoId, "&prettyPrint=false&t=") + tubeService.generateClientPlaybackNonce(12), { headers: {
                                    'Content-Type': 'application/json',
                                    'User-Agent': "com.google.ios.youtube/".concat(IOS_CLIENT_VERSION, "(").concat(IOS_DEVICE_MODEL, "; U; CPU iOS ").concat(IOS_USER_AGENT_VERSION, " like Mac OS X; en_US)"),
                                    'X-Goog-Api-Format-Version': '2',
                                }, body: JSON.stringify(payload) })];
                    case 1:
                        response = _a.sent();
                        body = response.body;
                        playErr = tubeService.playError(body);
                        if (playErr)
                            throw playErr;
                        try {
                            return [2 /*return*/, JSON.parse(body)];
                        }
                        catch (e) {
                            return [2 /*return*/, {}];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ;
    YTubeService.prototype.fetchAndroidJsonPlayer = function (videoId, tubeService) {
        return __awaiter(this, void 0, void 0, function () {
            var payload, response, body, playErr;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        payload = {
                            videoId: videoId,
                            cpn: tubeService.generateClientPlaybackNonce(16),
                            contentCheckOk: true,
                            racyCheckOk: true,
                            context: {
                                client: {
                                    clientName: 'ANDROID',
                                    clientVersion: ANDROID_CLIENT_VERSION,
                                    platform: 'MOBILE',
                                    osName: 'Android',
                                    osVersion: ANDROID_OS_VERSION,
                                    androidSdkVersion: ANDROID_SDK_VERSION,
                                    hl: 'en',
                                    gl: 'US',
                                    utcOffsetMinutes: -240,
                                },
                                request: {
                                    internalExperimentFlags: [],
                                    useSsl: true,
                                },
                                user: {
                                    lockedSafetyMode: false,
                                },
                            },
                        };
                        return [4 /*yield*/, got_1.default.post("https://youtubei.googleapis.com/youtubei/v1/player?id=".concat(videoId, "&prettyPrint=false&t=") + tubeService.generateClientPlaybackNonce(12), { headers: {
                                    'Content-Type': 'application/json',
                                    'User-Agent': "com.google.android.youtube/".concat(ANDROID_CLIENT_VERSION, " (Linux; U; Android ").concat(ANDROID_OS_VERSION, "; en_US) gzip"),
                                    'X-Goog-Api-Format-Version': '2',
                                }, body: JSON.stringify(payload) })];
                    case 1:
                        response = _a.sent();
                        body = response.body;
                        playErr = tubeService.playError(body);
                        if (playErr)
                            throw playErr;
                        try {
                            return [2 /*return*/, JSON.parse(body)];
                        }
                        catch (e) {
                            return [2 /*return*/, {}];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ;
    YTubeService.prototype.parseFormats = function (info) {
        var formats = [];
        if (info && info.streamingData) {
            if (info.streamingData.formats) {
                formats = formats.concat(info.streamingData.formats);
            }
            if (info.streamingData.adaptiveFormats) {
                formats = formats.concat(info.streamingData.adaptiveFormats);
            }
        }
        return formats;
    };
    YTubeService.prototype.between = function (haystack, left, right) {
        var pos;
        if (left instanceof RegExp) {
            var match = haystack.match(left);
            if (!match) {
                return '';
            }
            pos = match.index + match[0].length;
        }
        else {
            pos = haystack.indexOf(left);
            if (pos === -1) {
                return '';
            }
            pos += left.length;
        }
        haystack = haystack.slice(pos);
        pos = haystack.indexOf(right);
        if (pos === -1) {
            return '';
        }
        haystack = haystack.slice(0, pos);
        return haystack;
    };
    YTubeService.prototype.parallel = function (funcs, callback) {
        var funcsDone = 0;
        var errGiven = false;
        var results = [];
        var len = funcs.length;
        var checkDone = function (index, err, result) {
            if (errGiven) {
                return;
            }
            if (err) {
                errGiven = true;
                callback(err);
                return;
            }
            results[index] = result;
            if (++funcsDone === len) {
                callback(null, results);
            }
        };
        if (len > 0) {
            funcs.forEach(function (f, i) { f(checkDone.bind(null, i)); });
        }
        else {
            callback(null, results);
        }
    };
    YTubeService.prototype.cutAfterJSON = function (mixedJson) {
        var open;
        var close;
        if (mixedJson[0] === '[') {
            open = '[';
            close = ']';
        }
        else if (mixedJson[0] === '{') {
            open = '{';
            close = '}';
        }
        if (!open) {
            throw new Error("Can't cut unsupported JSON (need to begin with [ or { ) but got: ".concat(mixedJson[0]));
        }
        // States if the loop is currently in a string
        var isString = false;
        // Current open brackets to be closed
        var counter = 0;
        var i;
        for (i = 0; i < mixedJson.length; i++) {
            // Toggle the isString boolean when leaving/entering string
            if (mixedJson[i] === '"' && mixedJson[i - 1] !== '\\') {
                isString = !isString;
                continue;
            }
            if (isString)
                continue;
            if (mixedJson[i] === open) {
                counter++;
            }
            else if (mixedJson[i] === close) {
                counter--;
            }
            // All brackets have been closed, thus end of JSON is reached
            if (counter === 0) {
                // Return the cut JSON
                return mixedJson.substr(0, i + 1);
            }
        }
        // We ran through the whole string and ended up with an unclosed bracket
        throw Error("Can't cut unsupported JSON (no matching closing bracket found)");
    };
    ;
    YTubeService.prototype.playError = function (playerResponse) {
        var playability = playerResponse && playerResponse.playabilityStatus;
        if (!playability)
            return null;
        if (['ERROR', 'LOGIN_REQUIRED'].includes(playability.status)) {
            return new Error(playability.reason || (playability.messages && playability.messages[0]));
        }
        if (playability.status === 'LIVE_STREAM_OFFLINE') {
            return new Error(playability.reason || 'The live stream is offline.');
        }
        if (playability.status === 'UNPLAYABLE') {
            return new Error(playability.reason || 'This video is unavailable.');
        }
        return null;
    };
    ;
    return YTubeService;
}());
exports.YTubeService = YTubeService;
